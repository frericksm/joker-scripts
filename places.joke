#!/usr/bin/env joker
(ns places
  (:require [joker.tools.cli :as cli]
            [joker.os :as os]
            [joker.csv :as csv]
            [joker.time :as t]
            [joker.http :as h]
            [joker.math :as m]
            [joker.strconv :refer [atoi]]))
(def usage "Usage: places OPTIONS -d\nSample: places -d 2020-08-11")
(def opts
  [["-d" "--date DATE" "zum Datum DATE"]
   ["-v" "--verbose" "verbose"]
   ["-h" "--help" "berechnet die Raumbelegung durch 2 Personen"]])
(defn show-options
  [summary errors]
  (println usage)
  (println summary)
  (when errors
    (println "\nErrors:")
    (run! println errors)))
(defn debug [msg o]
  (do (println msg o) o))
;;;;;;;;;;;;

(def names ["Alex"  "Dirk" "Michael" "Nico"])
(def YYYY-MM-DD  "2006-01-02")
(def MDY "1/2/06")
(defn parse-date [t layout]
  (t/parse layout t))
(defn format-date [t layout]
  (t/format t layout))
(defn append-each 
  "append-each :: seq -> seq -> [Map]
  Returns a seq of maps  by creating a map with keys :seq and :rest for each e of elements. The value for :seq is seq s with e appended. The value for :rest is elements without e."
  [elements s]
  (as-> elements x
    (map (fn [e] (hash-map :seq  (vec (cons e s))
                           :rest (vec (remove (hash-set e) elements)))) x)))

(defn k-from-n 
  "k-from-n :: Int -> [a] [[a]]
  Antwortet mit der seq aller  seqs der Länge  k aus unterschiedlichen Elementen aus elements"
  [k elements]
  (loop [result (append-each elements [])
         i 1]
    (if (= i k) (vec (set (map set (map :seq result))))
        (let [new-i (inc i)
              new-result (reduce (fn [a {:keys [seq rest]}] (concat (append-each rest seq) a)) [] result)]
          (recur new-result new-i)))))

(defn days-since-monday-1970-01-05 
  "days-since-monday-1970-01-05 :: Time -> Int
  Antwortet mit der Anzahl Tage die seit dem 05.01.1970 vergangen sind. Der 05.01.1970 war ein Montag" 
  [date]
  (let [parsed-date (parse-date date YYYY-MM-DD)
        montag-date-1970-01-05 (parse-date "1970-01-05" YYYY-MM-DD)
        durarion-nanos (t/sub parsed-date  montag-date-1970-01-05)
        dur-hours (/ durarion-nanos t/hour)
        days-since (int (/ dur-hours 24))]
    days-since))
(defn werktage-since-date
  "werktag :: Time -> Int
  Antwortet mit der Anzahl Werktage seit Montag dem 05.01.1970" 
  [date]
  (let [days-since (days-since-monday-1970-01-05 date)
        result (+ (* 5 (int (/ days-since 7 )))
                  (min 5 (mod days-since 7)))]
    result))

(defn belegung
  "belegung :: String -> [String]
  Antwortet mit der Raumbelegung duch 2 Pesonen zum Datum. Es ist sichergestellt, daß jeder gleich oft ins Büro kann" 
  [date]
  (let [w (werktage-since-date date)
        alle-belegungen (k-from-n 2 names)
        result (nth alle-belegungen (mod w 6))]
result))

(defn start 
  "Schreibt die Raumbelegung zum date in die Konsole"
  [date verbose?]
  (println (format "Belegung von Raum C.10.041 am %s durch %s" date (belegung date))))

;; Entrypoint

(let [{:keys [options summary errors arguments]} (cli/parse-opts *command-line-args* opts)
      {:keys [help version ]} options
      verbose? (:verbose options)
      date-option (or (:date options) (format-date (joker.time/now) YYYY-MM-DD))
      ]
  #_(println options arguments)
  (cond
    errors
    (do
      (show-options summary errors)
      (os/exit -1))
    help
    (show-options summary nil)
    
    version
    (println "version: " version)
    :else
    (do
      (start  date-option verbose?)
      )))
